<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DxfHelper_CannotLoadFile_Path" xml:space="preserve">
    <value>Cannot load DXF file {0}</value>
  </data>
  <data name="DxfHelper_ReadingFile__FileName" xml:space="preserve">
    <value>Reading {0}</value>
  </data>
  <data name="Options_Help" xml:space="preserve">
    <value>Call: PathDxf2GCode [options] [DXF files]

Options:
    /h     Help text
    /f 000 Milling speed in mm/min; required
    /z 000 Probing speed in mm/min; default is /f value
    /v 000 Maximum speed for sweeps in mm/min; required
    /s 000 Default sweep height in mm; required
    /c     Check all paths in DXF file without writing GCode; if /c is not
           provided the DXF file must contain only one path layer
    /x zzz For all texts matching this regular expression, write assigned
           DXF objects; this is helpful for debugging parameter texts
    /d zzz Search path for references DXF files; can be specified multiple
           times; default is the location of the DXF file
    /n zzz Regular expression for path names; default value is 
           ([0-9]{4})[.]([0-9]+)([A-Z])
    /p zzz Regular expression for path patterns in file names; default is
           ([0-9]{4})(?:[.]([0-9]+))?
    /l zzz Language; default is operating system language
</value>
  </data>
  <data name="Options_LessThan0_Name_Value" xml:space="preserve">
    <value>Option value {1} for {0} ist not &gt;= 0</value>
  </data>
  <data name="Options_MissingF" xml:space="preserve">
    <value>/f missing or not &gt; 0</value>
  </data>
  <data name="Options_MissingOptionAfter_Name" xml:space="preserve">
    <value>Missing value after option {0}</value>
  </data>
  <data name="Options_MissingV" xml:space="preserve">
    <value>/v missing or not &gt; 0</value>
  </data>
  <data name="Options_MissingS" xml:space="preserve">
    <value>/v missing or not &gt; 0</value>
  </data>
  <data name="Options_MissingValue_Name" xml:space="preserve">
    <value>Missing value for option {0}</value>
  </data>
  <data name="Options_NaN_Name_Value" xml:space="preserve">
    <value>Option value {1} for {0} is not a number</value>
  </data>
  <data name="Options_NotSupported_Name" xml:space="preserve">
    <value>Option {0} not supported</value>
  </data>
  <data name="Params_BMustBeLessThanT_B_T" xml:space="preserve">
    <value>B={0} must not be larger than T={1}</value>
  </data>
  <data name="Params_CMustBeGtThan0_C" xml:space="preserve">
    <value>C={0} must be &gt; 0</value>
  </data>
  <data name="Params_UMustBeGtThan0_U" xml:space="preserve">
    <value>U={0} must be &gt; 0</value>
  </data>
  <data name="Params_PMustBeGtThan0_P" xml:space="preserve">
    <value>P={0} must be &gt; 0</value>
  </data>
  <data name="Params_DMustBeGtThanB_D_B" xml:space="preserve">
    <value>D={0} must be larger than B={1}</value>
  </data>
  <data name="Params_DMustBeLessThanT_D_T" xml:space="preserve">
    <value>D={0} must not be larger than T={1}</value>
  </data>
  <data name="Params_FMustBeGtThan0_F" xml:space="preserve">
    <value>F={0} must be &gt; 0</value>
  </data>
  <data name="Params_IMustBeGtThan0_I" xml:space="preserve">
    <value>I={0} must be &gt; 0</value>
  </data>
  <data name="Params_MissingKey_Key" xml:space="preserve">
    <value>{0} value missing</value>
  </data>
  <data name="Params_OMustBeGtThan0_O" xml:space="preserve">
    <value>O={0} must be &gt; 0</value>
  </data>
  <data name="Params_SMustBeGtThanT_S_T" xml:space="preserve">
    <value>S={0} must be above T={1} </value>
  </data>
  <data name="Params_AMustBeGtThan0_A" xml:space="preserve">
    <value>A={0} must be &gt; 0</value>
  </data>
  <data name="Params_WMustBeGtThan0_W" xml:space="preserve">
    <value>W={0} must be &gt; 0</value>
  </data>
  <data name="Params_TMustBeGtThan0_T" xml:space="preserve">
    <value>T={0} must be &gt; 0</value>
  </data>
  <data name="Params_UnsupportedKey_Name_Context" xml:space="preserve">
    <value>Unsupported {0} value; {1}</value>
  </data>
  <data name="Params_VMustBeGtThan0_V" xml:space="preserve">
    <value>V={0} must be &gt; 0</value>
  </data>
  <data name="PathModel_PathDefinedTwice_Path_OtherFile" xml:space="preserve">
    <value>Path {0} has already been defined in {1}</value>
  </data>
  <data name="PathModel_CircleTooSmall_D_O" xml:space="preserve">
    <value>Diameter {0} is smaller than O={1}</value>
  </data>
  <data name="PathModel_LineTypeNotSupported_LineType" xml:space="preserve">
    <value>Line type {0} not supported</value>
  </data>
  <data name="PathModel_LostEnd_End" xml:space="preserve">
    <value>End marker not near end of last traversed segment, but at {0} - add sweep</value>
  </data>
  <data name="PathModel_MissingEnd" xml:space="preserve">
    <value>End marker missing</value>
  </data>
  <data name="PathModel_MissingKey_Key" xml:space="preserve">
    <value>{0} value missing</value>
  </data>
  <data name="PathModel_MissingParams_Path" xml:space="preserve">
    <value>No parameters found for path {0}; maybe path text center is not near enough to start marker</value>
  </data>
  <data name="PathModel_MissingPathDefinition_PathName" xml:space="preserve">
    <value>Path definition {0} not found; maybe start marker is not of line type PHANTOM(__ _ _ __)</value>
  </data>
  <data name="PathModel_MissingStart" xml:space="preserve">
    <value>Start marker missing</value>
  </data>
  <data name="PathModel_MissingParamsText" xml:space="preserve">
    <value>Parameters text missing; maybe incorrect start marker</value>
  </data>
  <data name="PathModel_NoMoreSegmentsFound_P" xml:space="preserve">
    <value>No more segments found after location {0}</value>
  </data>
  <data name="PathModel_NoObjectFound_Text_Center_Diameter" xml:space="preserve">
    <value>No overlapping circle, arc or line found for '{0}'; maybe text center is not near enough to element (text circle: {1}, diam. {2}), or there is another overlapping text</value>
  </data>
  <data name="PathModel_NotSpecialCircle_Diameter" xml:space="preserve">
    <value>Circle with line type PHANTOM (__ _ _ __) and diameter {0} has no special meaning</value>
  </data>
  <data name="PathModel_TextAssignment_Obj_Text" xml:space="preserve">
    <value>Object
   {0}
has assigned text '{1}'</value>
  </data>
  <data name="PathModel_TextLayerDifferentFromElementLayer_TextLayer_ElementLayer" xml:space="preserve">
    <value>Text layer name '{0}' different from element layer name '{1}'</value>
  </data>
  <data name="PathModel_TextLayout_Text" xml:space="preserve">
    <value>Text {0} must be unrotated, with anchor at bottom left or top left</value>
  </data>
  <data name="PathModel_TwoEnds_E1_E2" xml:space="preserve">
    <value>Two end markers defined at {0} and {1}</value>
  </data>
  <data name="PathModel_TwoStarts_S1_S2" xml:space="preserve">
    <value>Two start markers defined at {0} and {1}</value>
  </data>
  <data name="PathModel_UnreachedSegments" xml:space="preserve">
    <value>{0} segments (e.g. this one here) not reached - maybe N value is missing</value>
  </data>
  <data name="PathSegment_CallDepthGt9_Path" xml:space="preserve">
    <value>Nesting depth deeper than 9 levels at path {0}</value>
  </data>
  <data name="PathSegment_DifferingM_Caller_Path_Called" xml:space="preserve">
    <value>M={0} at subpath {1} is different from M={2} in referenced path</value>
  </data>
  <data name="PathSegment_DifferingO_Caller_Path_Called" xml:space="preserve">
    <value>O={0} at subpath {1} is different from O={2} in referenced path</value>
  </data>
  <data name="PathSegment_DistanceDiffers_CallerDist_ModelName_CalledDist" xml:space="preserve">
    <value>Subpath size {0} is not equal to size {2} in referenced path {1}</value>
  </data>
  <data name="PathSegment_GtMissing" xml:space="preserve">
    <value>&gt;... missing</value>
  </data>
  <data name="PathSegment_InvalidPathName_Dir_Path" xml:space="preserve">
    <value>'{0}{1}' is not a valid path name</value>
  </data>
  <data name="PathSegment_PathNotFound_Name_Files" xml:space="preserve">
    <value>Could not find path {0} in file(s) {1}</value>
  </data>
  <data name="Program_Checking_Path" xml:space="preserve">
    <value>Checking {0}</value>
  </data>
  <data name="Program_CommandCount" xml:space="preserve">
    <value>Command count:</value>
  </data>
  <data name="Program_DrillingLength" xml:space="preserve">
    <value>Drill length:</value>
  </data>
  <data name="Program_MillingLength" xml:space="preserve">
    <value>Milling length:</value>
  </data>
  <data name="Program_MoreThanOnePathLayer_File_Paths" xml:space="preserve">
    <value>DXF file {0} contains more than one path layer: {1}</value>
  </data>
  <data name="Program_NoDxfFiles" xml:space="preserve">
    <value>No dxf files provided</value>
  </data>
  <data name="Program_NoErrorFreePathLayer_File" xml:space="preserve">
    <value>DXF file {0} contains no error-free path layer</value>
  </data>
  <data name="Program_NoSegmentsFound" xml:space="preserve">
    <value>No segments found</value>
  </data>
  <data name="Program_SumLength" xml:space="preserve">
    <value>Sum:</value>
  </data>
  <data name="Program_SweepLength" xml:space="preserve">
    <value>Sweeps:</value>
  </data>
  <data name="Program_Writing_Path" xml:space="preserve">
    <value>Writing {0}</value>
  </data>
  <data name="Transformation2_DifferentDistances_FromS_FromE_FromD_ToS_ToE_ToD" xml:space="preserve">
    <value>Distance {0}...{1} = {2} ist not equal to distance {3}...{4} = {5}</value>
  </data>
  <data name="PathSegment_DiameterGtA_Diameter_A" xml:space="preserve">
    <value>Diameter {0} of helix circle is larger than A={1}; possibly replace with arc path</value>
  </data>
  <data name="Variables_Error_Message" xml:space="preserve">
    <value>Error in variable definition: {0}</value>
  </data>
  <data name="Variables_RangeHasMoreThanTwoNumbers_Variable_Range" xml:space="preserve">
    <value>Range for variable {0} must have format ###~### instead of '{1}'</value>
  </data>
  <data name="Variables_DefinitionNeitherListNorLettersNorRange_Variable_Definition" xml:space="preserve">
    <value>Definition for variable {0} must be comma-separated list, or letters group starting with ?, or range ...~... instead of '{1}'</value>
  </data>
  <data name="Variables_MissingValues_Variables" xml:space="preserve">
    <value>Missing values for variables {0}</value>
  </data>
  <data name="Variables_MissingDefinitions_Variables" xml:space="preserve">
    <value>Missing definitions for variables {0}</value>
  </data>
  <data name="Variables_ValueDoesNotMatchDefinition_Value_Definition_Variable" xml:space="preserve">
    <value>Value '{0}' of variable {2} does not match definition '{1}'</value>
  </data>
  <data name="Variables_RangeFormatError_Variable_Message" xml:space="preserve">
    <value>Wrong number format in range for variable {0} ({1})</value>
  </data>
  <data name="Params_DuplicateParametersFound_Text_Duplicates" xml:space="preserve">
    <value>The parameter(s) {1} are specified more than once in '{0}'</value>
  </data>
  <data name="Params_NCannotUseVariable_Text" xml:space="preserve">
    <value>N parameter '{0}' cannot use variable</value>
  </data>
  <data name="Params_OCannotUseVariable_Text" xml:space="preserve">
    <value>O parameter '{0}' cannot use variable</value>
  </data>
  <data name="Params_PathNotFoundInThisDXF_Name" xml:space="preserve">
    <value>Path {0} referenced with @ not found in this DXF file</value>
  </data>
  <data name="Params_AtNotAllowedInReferencedPathText_Text" xml:space="preserve">
    <value>@ not allowed in path '{0}' which is itself referenced by @</value>
  </data>
  <data name="Params_AtCannotUseVariable_Text" xml:space="preserve">
    <value>@ path '{0}' cannot use variable</value>
  </data>
  <data name="Params_AtCannotContainOtherParameters_Text" xml:space="preserve">
    <value>@ path '{0}' must not contain other parameters</value>
  </data>
  <data name="Params_AtPathDoesNotMatchPathNamePattern_Text_Pattern" xml:space="preserve">
    <value>@ path '{0}' does not match path pattern /{1}/</value>
  </data>
</root>